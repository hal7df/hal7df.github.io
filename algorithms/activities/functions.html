<!DOCTYPE html>
<!--
  Material Design Lite
  Copyright 2015 Google Inc. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      https://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License
-->
<html>
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Functions &#8212; IA Algorithms Enrichment 2017</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="../res/material.min.css">
	<link rel="stylesheet" href="../res/page.css">
	<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
	<link rel="stylesheet" type="text/css" href="syntax/css/shCore.css" />
    <link rel="stylesheet" type="text/css" href="syntax/css/shThemeDefault.css" />
    <script type="text/javascript" src="syntax/script/shCore.js"></script>
    <script type="text/javascript" src="syntax/script/shBrushCpp.js"></script>
    <style>
    .spoiler {
    	background-color: #e0e0e0;
    	text-align: center;
    }
    .spoiler > .contents,
    .spoiler:hover > .banner {
    	display: none;
    }
    .spoiler:hover > .contents {
    	display: inline;
    }
    </style>
</head>
<body class="mdl-base">
	<div class="demo-layout mdl-layout mdl-layout--fixed-header mdl-js-layout mdl-color--grey-100">
      <header class="demo-header mdl-layout__header mdl-layout__header--scroll mdl-color--grey-100 mdl-color-text--grey-800">
        <div class="mdl-layout__header-row">
          <span class="mdl-layout-title">IA Algorithms Enrichment 2017</span>
        </div>
      </header>
      <div class="demo-ribbon"></div>
      <main class="demo-main mdl-layout__content">
        <div class="demo-container mdl-grid">
          <div class="mdl-cell mdl-cell--2-col mdl-cell--hide-tablet mdl-cell--hide-phone"></div>
          <div class="demo-content mdl-color--white mdl-shadow--4dp content mdl-color-text--grey-800 mdl-cell mdl-cell--8-col">
            <div class="demo-crumbs mdl-color-text--grey-500">
              <a href="../index.html#activities">Activities</a> &gt; Nov 4 &gt; Functions
            </div>
            <h2>Functions</h2>
			<p>So far, you have learned how to create variables, write text and data to the screen, receive input from the user, make decisions based on data held in variables, and loop
				code based on a condition. And, in truth, this is tha majority of all you really need to write any program you want in C++ (the other useful thing to have is the ability to make arrays,
				which we will discuss shortly) -- these features are what makes C++ <span class="italic">Turing complete</span>, or capable of solving any problem a computer can solve.
				But the problem is that writing more advanced programs than the ones you have seen so far are incredibly difficult without the use of more higher-level programming language features
				(i.e. those that create arbitrary constructs and translate them into). So, the first such construct we will look at is a function.</p>
			<p>A function in programming is not too different from a function that you might use in algebra. It takes in an input and spits out an output by doing something to that input.
				However, functions in programming can do a lot more than what we typically use them for in math. To elaborate:</p>
			<ul>
				<li>A function can take any number of inputs, or no inputs at all</li>
				<li>The inputs of a function can be of any data type (including <code>string</code>!), and they need not all be the same</li>
				<li>A function can "return" (output) any data type (including <code>string</code>!), or return nothing at all</li>
			</ul>
			<p>In programming, we typically use functions to avoid writing repetitive code, as well as to organize our code. If we find ourselves writing the same code (or very similar code) several times
				over and over again, we begin setting ourselves up for failure: if one of those instances of that code fails, we have to spend lots of time trying to find it and debug it; if
				<span class="italic">all</span> of the instances fail, we have to spend time debugging and fixing <span class="italic">every single one of them</span>, and it can be hard to distinguish
				one instance from another. Functions are <span class="italic">abstractions</span>, or programming language structures that allow us to wrap code in a common interface, allowing quick reuse of existing code.
				As such, when you use a function to implement repetitive code, and you find that the function is wrong, or needs to be improved, and you fix or improve that function,
				after which <span class="underline">all other code that uses that function will be fixed or improved without you doing anything else</span>.
				Being able to understand and write code using such abstractions is highly valued when writing large software projects.</p>
			<p>In this page:</p>
			<ul>
				<li><a href="#code-snippets">A quick note</a>
				<li><a href="#basics">Function basics</a></li>
				<li><a href="#void"><code>void</code> functions</a>
				<li><a href="#passing">Passing values</a></li>
				<li><a href="#constness"><code>const</code>ness</a></li>
			</ul>
			<h3 id="code-snippets">A quick note</h3>
			<p>Thus far, almost all of the example code that you have seen has been complete -- it has all the appropriate <code>#include</code> statements, has <code>using namespace std</code> at the top,
				defines a function <code>main</code> and has <code>return 0</code> at the end. As we learn more programming constructs, writing out the full program will become excessively long at points,
				so instead, many of the code snippets here will be fragments of the full source, which demonstrate only the code we're discussing.
				There will still be full-length example programs where they are necessary to demonstrate a concept,
				but it is expected that you will be able to understand where the example code belongs in the overall source file.</p>
			<h3 id="basics">Function basics</h3>
			<p>As it turns out, you have already seen what a function looks like:</p>
			<pre class="brush: cpp">
int main () {
	//some code...
	
	return 0;
}</pre>
			<p><code>main</code> is an example of a function. Let's examine a little more closely what all of this means:</p>
			<pre class="brush: cpp">int main ()</pre>
			<p>Here, we are defining a function called <code>main</code> that outputs (returns) an <code>int</code> and takes no input parameters (the empty parentheses).
				This description is known as a function's <span class="italic">signature</span>, or the aspects of a function that uniquely identify it:  name, return type, and parameters.
				The reason that we always define this function is because it is your program's <span class="italic">entry point</span> -- the operating system starts your program by calling
				its <code>main</code> function.</p>
			<p>OK, let's look at the other function-related line in the code:</p>
			<pre class="brush: cpp">return 0;</pre>
			<p>This is <code>main</code>'s <span class="italic">return statement</span>, which is how <code>main</code> tells the computer what its "output" is
				(or, using math terms, what <code>main</code> "evaluates to"). The <code>0</code> is the <code>main</code>'s <span class="italic">return value</span>, which is the value
				that <code>main</code> will evaluate to. The type of a function's return value must <span class="underline">always</span> match its return type (in this case, <code>int</code>, as in <code>int main</code>), otherwise it will
				not compile (this is under the same principle that you cannot store values of a differing data type in a variable).</p>
			<p>Functions neither need to have the <code>int</code> return type, nor return the value <code>0</code>
				(0 is actually just a <a href="http://tldp.org/LDP/abs/html/exitcodes.html" target="_blank">message to the operating system</a> to tell it if the program had any execution errors). You can return any
				data type, such as <code>double</code>, <code>bool</code>, <code>string</code>, or even one of your own, when we learn abstract data types.</p>
			<p>Generally speaking, a function looks like this:</p>
			<pre class="brush: cpp">
returnType functionName (inputParameterList) {
	//code
	return value;
}</pre>
			<p>Let's expand the idea of a function just by starting with a regular algebra function: f(x) = x<sup>2</sup>. Let's implement this as a function in C++:</p>
			<pre class="brush: cpp">
double f (double x) {
	return x * x;
}</pre>
			<p>Now, we've changed some things from before: instead of returning an <code>int</code>, we now return a <code>double</code>; and instead of taking no parameters,
				we now have one: <code>x</code>, which is a <code>double</code>. Inside the function, <code>x</code> is just a regular variable with type <code>double</code>, and we can use it
				just like we would any other variable. Note that we did not have to declare it in the function body -- because we gave the variable a type and a name in the parameter list,
				the compiler knows all it needs to make a regular variable from that alone.</p>
			<p class="italic">For those wondering: We wrote <code>x * x</code> because <code>^</code> is <span class="underline">not</span> exponentiation in C++
				(<a href="http://www.cplusplus.com/doc/tutorial/operators/#bitwise" target="_blank">it's actually bitwise XOR</a>). There is a function in the <code>cmath</code>
				header file (<code>#include &lt;cmath&gt;</code>) called <a href="http://www.cplusplus.com/reference/cmath/pow/" target="_blank"><code>pow</code></a>
				that computes arbitrary powers, but it is actually faster in terms of runtime to just multiply a number by itself than it is to call <code>pow(x, 2)</code>.</p>
			<p>So, now we have written a function for f, but how do we use it? Let's go back to our <code>main</code>:</p>
			<pre class="brush: cpp">
int main () {
	double a;
	
	cout &lt;&lt; "Please input a number: ";
	cin >> a;
	
	cout &lt;&lt; a &lt;&lt; "^2 = " &lt;&lt; f(a) &lt;&lt; endl;
	
	return 0;
}</pre>
			<p class="output">Please input a number: <span class="input">5</span><br/>5^2 = 25</p>
			<p>This is called a <span class="italic">function call</span>. A function call is exactly like you would expect -- the name of the function, followed by the inputs you are passing to it in parentheses.
				When execution reaches this point, the program calls that function with its input <code>x</code> set to the value of <code>a</code>; <code>f</code> then executes its body until its return statement
				is reached. When <code>f</code> returns, control returns to <code>main</code>, where the function call evaluates to the return value of <code>f</code> (in this case, 25). <code>cout</code> sees the
				value <code>25</code>, and thus prints <code>25</code> to the screen.</p>
			<p>Now, let's do a little more with functions, something more akin to what you might do in a program:</p>
			<pre class="brush: cpp">
string guessMyNumber (int a, int b) {
	string msg;
	int sum = a + b;
	
	if (sum >= 52 || sum &lt= 32)
		msg = "That is very far from my number.";
	else
		msg = "That is close to my number!";
		
	return msg;
}

int main () {
	int num1, num2;
	string result;
	
	cout &lt;&lt; "Input two integers to be summed: ";
	cin >> num1 >> num2;
	
	result = guessMyNumber(num1, num2);
	
	cout &lt;&lt; result &lt;&lt; endl;
	return 0;
}</pre>
			<p class="output">Input two integers to be summed: <span class="input">648 8964</span><br/>That is very far from my number.</p>
			<p>Note that we now have multiple input parameters -- we separate these by inserting a comma between each parameter. When you call a function with multiple parameters,
				order matters -- so, in this example, <code>num1</code> is passed to <code>guessMyNumber</code> as <code>a</code>, and <code>num2</code> is passed as <code>b</code>.
				If we instead wrote <code>guessMyNumber(num2, num1)</code>, then <code>a</code> would have the same value as <code>num2</code>, and <code>b</code> would have the same
				value as <code>num1</code>. If we only called <code>guessMyNumber</code> with one input (say, <code>guessMyNumber(num1)</code>), then the compiler would error out when
				you try to compile, as <code>guessMyNumber</code> expects two inputs. The same thing would happen if you called it with three or more inputs.</p>
			<p>Just like we do in <code>main</code>, we can use any lanuage constructs we have learned so far -- variables, <code>if-else</code> statements, loops -- in other functions as well.
				Here, we return a string that indicates whether the user input two numbers that sum close to 42.</p>
			<p>Note that, just because <code>guessMyNumber</code> is defined before <code>main</code>, <code>main</code> still executes first (recall that <code>main</code> is the entry point for your program).
				The program will ask the user for two integers, then passes them to <code>guessMyNumber</code>, which sums the integers and uses the result and stores a message in a string named <code>msg</code>,
				which is then returned back to <code>main</code>. <code>main</code> then stores the message in a variable named <code>result</code>, which is subsequently printed to the screen.</p>
			<p>So far, all of the functions we have seen so far have a <code>return</code> statement as the last statement in the function body. However, this isn't a requirement -- a
				<code>return</code> can appear anywhere in the function body, so long as the following requirements are met:</p>
			<ul>
				<li>A <code>return</code> statement is <span class="underline">always</span> executed</li>
				<li>All <code>return</code> statements in your code return variables or values that are appropriate for the return type.</li>  
			</ul>
			<p>As such, in order to meet these requirements (namely the first), if you have a <code>return</code> statement in the middle of your function body, you are going to need multiple return statements
				in your source. This pattern is often used to detect invalid inputs and quit the function early and gracefully before the function does anything with those inputs. Let's see an example:</p>
			<pre class="brush: cpp; highlight: [5, 14]">
/* Converts a lowercase letter to uppercase.
   This function is implemented in the standard &lt;cctype&gt; header */
char toUpper (char letter) {
	//If the letter is not lowercase, then just return the input
	if (!(letter >= 'a' && letter &lt;= 'z')) return letter;
	
	/* ASCII -- how computers represent letters -- gives lowercase letters a
	   higher value than lowercase, so we need to subtract the difference
	   between the two. You can see the mapping here:
	   https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html
	   Internally, C++ treats all characters just as regular numbers
	   (mapped according to the table above), so we can use math to figure out
	   the right difference. */
	return letter - ('a' - 'A');
}</pre>
			<p>Now, note that if <code>letter</code> is not a lowercase letter, this function will simply return the input letter, but more importantly,
				it will <span class="bold">not</span> execute the second return statement on line 14 -- control will return to the calling function, which will resume execution.</p>
				
			<h4 id="prototyping">Prototyping</h4>
			<p>In the last example above, you may have noticed that <code>guessMyNumber</code> was defined before <code>main</code>. Why is that?</p>
			<p>C++ compilers are only required to know about things that exist in the source before any particular line. You <span class="italic">could</span>
				define <code>guessMyNumber</code> after <code>main</code>, except it may not compile -- the compiler might think that <code>guessMyNumber</code> doesn't exist
				because it simply hasn't reached it yet.</p>
			<p>That said, we usually want to make <code>main</code> the first actual code in our file, since this is where execution begins, and we don't want to go digging for
				<code>main</code> in a file full of functions. How do we fix this problem?</p>
			<p>The answer: you <span class="italic">prototype</span> your functions. Prototyping basically tells the compiler that a function with a particular signature does exist, but it does
				not actually define the function (that is done later). Let's rewrite the above example, but with a function prototype:</p>
			<pre class="brush: cpp; highlight: [2]">
//This is the prototype
string guessMyNumber (int a, int b);

int main () {
	int num1, num2;
	string result;
	
	cout &lt;&lt; "Input two integers to be summed: ";
	cin >> num1 >> num2;
	
	result = guessMyNumber(num1, num2);
	
	cout &lt;&lt; result &lt;&lt; endl;
	return 0;
}

//This is the definition
string guessMyNumber (int a, int b) {
	string msg;
	int sum = a + b;
	
	if (sum >= 52 || sum &lt= 32)
		msg = "That is very far from my number.";
	else
		msg = "That is close to my number!";
		
	return msg;
}</pre>
			<p>Now, you'll notice that the prototype and the first line of the function definition are almost identical
				-- they both have the same format, listing the function's return type, name, and parameters, except the
				prototype ends with a semicolon (instead of an opening curly brace).
				This has allowed us to move the definition of <code>guessMyNumber</code> after <code>main</code>.</p>
			<p>You can prototype and define any number of functions in the same file; it is recommended that you use the following format when writing source code with functions:</p>
			<pre class="brush: cpp">
//any #includes here
using namespace std; //if necessary

//All of your function prototypes go here. Do not prototype main.

int main () {
	//code...
	
	return 0;
}

//All of the prototyped functions are defined here.</pre>
			<p class="italic">Why not prototype <code>main</code>? The entire purpose of prototyping was to make <code>main</code> the first function that is defined in the source file.
				You could prototype <code>main</code>, but it's pointless -- <code>main</code> is defined before anything else, so there is no dependency issue here.</p>
			
			<h4 id="basics-activity">Activity</h4>
			<p>Write the following programs with one or more function(s). Be sure to prototype any functions other than <code>main</code> that you write.</p>
			<ul>
				<li>Ask the user for a <code>double</code> input <code>x</code>, and output the result of the following piecewise function:
					<ul>
						<li>If <code>x &lt; 0</code>, f(x) = 0</li>
						<li>If <code>x >= 0 && x &lt; 5</code>, f(x) = 2x</li>
						<li>If <code>x >= 5 && x &lt; 10</code>, f(x) = -x<sup>2</sup> + 10x - 15</li>
						<li>If <code>x >= 10</code>, f(x) = 0</li>
					</ul>
				</li>
				<li><span class="italic">Pythagorean theroem</span>: Ask the user for two <code>double</code>s, and output the length of the hypotenuse of the right triangle formed by using those inputs as leg lengths.
					<ul>
						<li>The Pythagorean theorem states that a right triangle with leg lengths <span class="italic">a, b</span> and hypotenuse length <span class="italic">c</span> is represented by the equation
							a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>.</li>
						<li>To compute a square root, put <code>#include &lt;cmath&gt;</code> at the top of your source file and use the
							<a href="http://www.cplusplus.com/reference/cmath/sqrt" target="_blank"><code>sqrt()</code></a> function.</li>
					</ul>
				</li>
			</ul>
			<h3 id="void"><code>void</code> functions</h3>
			<p>So, we have seen that we can write functions to abstract code and return some value that the code is designed to produce.
				But what if we just want to abstract away code for the sake of having the abstraction, not caring about the return value at all? Enter the <code>void</code> function.</p>
				
			<pre class="brush: cpp">
void printName (string name) {
	cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; '!' &lt;&lt; endl;
}
</pre>
			<p>In the above example, you can see two things that are different from before:</p>
			<ul>
				<li>The return type is <code>void</code>.</li>
				<li>There is no return statement.</li>
			</ul>
			<p>The change in the return type should come as no surprise, but what about the <code>return</code> statement? Well, because we don't need to return anything, we can omit it;
				the compiler assumes that the function will stop executing when it reaches the end of the function body. In a sense, void functions still "return" to their caller
				(the function that called them), but they do not evaluate to any particular value after being called.</p>
			<p>Because <code>void</code> functions don't return anything, none of the following calls to <code>printName</code> would work:</p>
			<pre class="brush: cpp">
string myName = "John Doe"
int a = printName(myName);	//assigning nothing into an int!
cout &lt;&lt; printName(myName) &lt;&lt; endl;	//printing out nothing!</pre>
			
			<p>But what if we wanted to have an early return? Like we saw with <code>toUpper</code>, we might have some input (or combination of inputs) that are "invalid" that still prevent
				the <code>void</code> function from executing properly; so we will want to stop its execution early. As it turns out, just because the function is <code>void</code> does not mean
				that it can't have a <code>return</code> statement; rather, the <code>return</code> statement can't have a return value. So, you might have a function that looks like this:</p>
			<pre class="brush: cpp; highlight: [7]">
/* **NOTE**: Ideally, this function should return the average, after which the
             caller would print it, but for the sake of example we are printing
             the average here */
//Take a sum and a count and print the average
void printAvg (double sum, int n) {
	//Can't divide by 0! So just exit
	if (n == 0) return;
	
	cout &lt;&lt; "Average: " &lt;&lt; (sum/n) &lt;&lt; endl;
}</pre>
			<h4 id="void-activity">Activity</h4>
			<p>Ask the user for an <code>int</code>, and output the following triangle:</p>
			<p class="output">#<br/>##<br/>###<br/>####<br/>...<br/>######</p>
			<p>where the triangle's height and the length of the last line are both the number that the user input.
				Be sure to write a <code>void</code> function that prints this triangle for a given integer input.</p>
			<h3 id="passing">Passing values</h3>
			<p>So, we have been able to create and call functions using inputs, but how exactly are those inputs passed to the function?
				Or, we could reframe it as such: what happens if we were to change the parameters in a function? Would we see the change in the caller?</p>
			<p>Let's find out:</p>
			<pre class="brush: cpp">
#include &lt;iostream&gt;
using namespace std;

void doSomething (int a);

int main () {
	int x = 5;
	
	doSomething(x);
	
	cout &lt;&lt; x &lt;&lt; endl;
	
	return 0;
}

void doSomething (int a) {
	a = 10;
}</pre>
			<p class="output">5</p>
			<p>So, changing the value of the input (<code>a</code>) inside of <code>doSomething</code> had no effect on the value of <code>x</code> in <code>main</code>.
				This is because function parameters are <span class="italic">passed by value</span>, in other words, the computer copies the value of the input parameter to a new variable in
				the new function, which then operates on that copy, instead of the original. So, in the above example, you could change <code>a</code> any number of times in any
				number of ways, but <code>x</code> in <code>main</code> will still be <code>5</code> when <code>doSomething</code> returns.</p>
			<p>But what if we wanted to change <code>x</code> from <code>doSomething</code>? To do this, we tell the compiler to <span class="italic">pass by reference</span>; or, instead
				of copying the value of the variable into a new variable, simply make a new name for the original variable and use that in the function. Let's change our example so it
				passes by reference:</p>
			<pre class="brush: cpp">
#include &lt;iostream&gt;
using namespace std;

//Notice the change both here and in the function definition
void doSomething (int &a);

int main () {
	int x = 5;
	
	doSomething(x);
	
	cout &lt;&lt; x &lt;&lt; endl;
	
	return 0;
}

void doSomething (int &a) {
	a = 10;
}</pre>
			<p class="output">10</p>
			<p>The change is subtle: we added a <code>&</code> before the variable name in the parameter list in both the function prototype and the function definition.
				Note that the reference does <span class="italic">not</span> have the same name as the original variable.</p>
			<p>Now, we see that making the change to <code>a</code> in <code>doSomething</code> affects the variable <code>x</code> in <code>main</code>.
				This is called a <span class="italic">side effect</span>.</p> 
			<h3 id="constness"><code>const</code>ness</h3>
			<p>Let's take a brief break from functions and talk about variables (keep passing by reference fresh in your mind, though, we will need it shortly).
				Up until now, your variable declarations have been pretty simple and straightforward:</p>
			<pre class="brush: cpp">int x;
string myStr;</pre>
			<p>The above code snippet creates two variables that you can assign a value to, read from, and reassign as much as you would like.
				However, there may be a time when you <span class="italic">don't</span> want your variables to change -- you still want them to hold a value, but that value
				should never change. As it turns out, there are a lot of modifiers that you can tack on to your variable declarations that modify the behavior of those variables.
				One such modifier, <code>const</code>, tells the compiler that <span class="bold">the value of the variable should never change once set</span>:</p>
			<pre class="brush: cpp">
#include &lt;iostream&gt;
using namespace std;

int main () {
	const int MY_NUM = 42;
	int i;
	
	cout &lt;&lt; "Please input a number: ";
	cin >> i;
	
	cout &lt;&lt; MY_NUM + i &lt;&lt; endl;
	
	return 0;
}</pre>
			<p class="output">Please input a number: <span class="input">7</span><br/>49</p>
			<p>So far, nothing out of the ordinary. Let's try modifying <code>MY_NUM</code>:</p>
			<pre class="brush: cpp">
#include &lt;iostream&gt;
using namespace std;

int main () {
	const int MY_NUM = 42;
	int i;
	
	cout &lt;&lt; "Please input a number: ";
	cin >> i;
	
	++MY_NUM;	//attempting to modify MY_NUM
	
	cout &lt;&lt; MY_NUM + i &lt;&lt; endl;
	
	return 0;
}</pre>
			<p class="compiler">const.cpp:11:4: error: increment of read-only variable `MY_NUM'</p>
			<p>As you can see, the compiler now errors out when we try to modify <code>MY_NUM</code>.</p>
			<p>Why would we want to keep ourselves from modifying a variable? Well, the general answer to this question is that there are lots of cases
				where we do <span class="italic">not</span> want to modify a variable -- most especially when dealing with functions. It is very easy to
				modify a variable -- even if by accident. Adding <code>const</code> to a variable makes the compiler enforce this restriction for us, to
				ensure that no modification takes place.</p>
			<p>When would this be the case? Let's see.</p>
			<h4 id="const-ref"><code>string</code> is hiding a secret</h4>
			<p>For the sake of argument, let's make our own print function. It will just use <code>cout</code> internally, but it will take a single string as an input.
				I give you the following two implementations of the print function:</p>
			<pre class="brush: cpp">
#include &lt;iostream&gt;
using namespace std;

void printValue (string str);
void printRef (string &str);

int main () {
	string myStr;
	
	cout &lt;&lt; "Input a string: ";
	cin >> myStr;
	
	/* We comment one call out so only one print function is called, but
	   we can quickly switch between the two when needed */
	for (int i = 0; i &lt; (1 &lt;&lt; 20); ++i) {	//1 &lt;&lt; 20 == 2^20
		printValue(myStr);
		//printRef(myStr);
	}
	
	return 0;
}

void printValue (string str) {
	cout &lt;&lt; str &lt;&lt; endl;
}

void printRef (string &str) {
	cout &lt;&lt; str &lt;&lt; endl;
}</pre>
			<p>Ostensibly, both functions do the same thing: they print the print the string that is passed to the function, followed by a newline, and then return.
				The only difference is that <code>printValue</code> takes <code>str</code> by value, and <code>printRef</code> takes a value by reference.
				Note how the <code>for</code> loop calls each function 1000 times.</p>
			<p>I have generated a massive input for <code>myStr</code> -- 32768 (2<sup>15</sup>) characters. We will perform the following experiment: run this program as shown above with
				the massive input and record how long it took, then we will comment out line 15 and uncomment line 16
				-- so we now call <code>printRef</code> instead of <code>printValue</code> -- and then run the program on the exact same input and record the time.
				What do you think will happen?</p>
			<p class="spoiler">
				<span class="banner">Think about it first, then roll over to see result</span>
				<span class="contents"><code>printValue</code> took 2.154 seconds; <code>printRef</code> took 0.511 seconds</span>
			</p>
			<p>Why such a big difference? Well, the problem lies with how <code>string</code> is implemented under the hood. A <code>string</code> is implemented as a container arround a
				sequence of characters (we will discuss this sequence in more depth when we discuss arrays). While a single <code>char</code> is quite small (in fact, it is tied for the smallest
				data type in C++, the other being <code>bool</code>), a very long sequence of them can be quite large (in this specific case, 33 kilobytes). Because we passed by value and not reference,
				we were copying those 33 kilobytes to the new function -- <span class="italic">2<sup>20</sup> times</span>. However, when we passed by reference, we weren't making any copies of the string --
				instead, we just made new names for the same variable; so, the computer had to do much less work here.</p>
			<p>We wouldn't notice this behavior with any of the other data types we have seen thus far -- the numeric data types all have fixed size, and the largest of which (<code>double</code>) is still only
				8 bytes, which can be copied by a computer relatively quickly. <code>string</code>s, on the other hand, grow with the size of their contents, and tend to be large by default, so the performance
				hit for copying a <code>string</code> is much greater.</p>
			<p>But remember -- <span class="italic">references allow us to modify the original variable</span>. But <code>printRef</code> isn't supposed to do this -- all it should do is print the value, not modify it.
				This is where <code>const</code> comes into play. We can use <code>const</code> in combination with the reference to tell the compiler that we want to pass by reference,
				<span class="italic">but not modify</span> the variable:</p>
			<pre class="brush: cpp">
void printRef (const string &str) {
	cout &lt;&lt; str &lt;&lt; endl;
}</pre>
			<p>Now, if we tried to make any modifications to <code>str</code> in the code, the compiler would tell us.
				Now we have the benefits of passing by reference with the guarantee that <code>str</code> will not be modified.</p>
			<p>Generally speaking, you use this pattern when dealing with large data types (we will see more of these when we discuss abstract data types), but not with small data types.
				The reason for this is because the computer still has to perform a copy under the hood (the amount of data copied is 4 bytes on a 32-bit system and 8 bytes on a 64-bit system)
				to support the reference, and simply copying small data such as an <code>int</code> or a <code>double</code> has the same (or better) performance. However, if you do need a function
				to modify the original input variables, then you should pass by (non-<code>const</code>) reference.
          </div>
        </div>
       </main>
      </div>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
</body>
</html>